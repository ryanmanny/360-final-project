****************************************************
****************util.c **************************
****************************************************
/************** util.c file ****************/
#include "type.h"

char *tokens[64];
FS     filesystems[NMOUNT], *root_fs, *cur_fs;

// FUNCTIONS
int get_block(int fd, int blk, char buf[ ])
{
    lseek(fd, (long) blk * BLKSIZE, 0);
    read(fd, buf, BLKSIZE);

    return 0;
}

int put_block(int fd, int blk, char buf[ ])
{
    lseek(fd, (long) blk * BLKSIZE, 0);
    write(fd, buf, BLKSIZE);

    return 0;
}

int tokenize(char *str, char *delim, char *tokens[])
{
    // Tokenize str into tokens array, assume it's large enough
    int count = 0;

    char *temp = strtok(str, delim);  // first call to strtok()
    if (!temp) return 0;
    else tokens[count++] = temp;

    // Call strtok() until it returns NULL
    while ((tokens[count] = strtok(NULL, delim)))
    {
        count++;
    }

    // Return # of tokens
    return count;
}

MINODE *iget(FS *fs, int ino)
{
    // Get a MINODE * matching ino from a filesystem
    MINODE *mip;
    INODE *ip;

    char buf[BLKSIZE];
    INODE_LOCATION location;

    /*(1). Search minode[] for an existing entry (refCount > 0) with
       the needed (dev, ino):
       if found: inc its refCount by 1;
            return pointer to this minode;*/
    for (int i = 0; i < NMINODE; i++)
    {
        if (fs->minode[i].dev == fs->dev && fs->minode[i].ino == ino)
        {
            fs->minode[i].refCount++;
            return &fs->minode[i];
        }
    }

    /*(2). // needed entry not in memory:
       find a FREE minode (refCount = 0); Let mip-> to this minode;
       set its refCount = 1;
       set its dev, ino*/
    for (int i = 0; i < NMINODE; i++)
    {
        if (fs->minode[i].refCount == 0)
        {
            fs->minode[i].refCount = 1;
            mip = &fs->minode[i];
            mip->dev = fs->dev;
            mip->ino = ino;
            mip->fs = fs;
            break;
        }
    }

    //*(3). load INODE of (dev, ino) into mip->INODE:
    location = mailman(fs, ino);

    get_block(fs->dev, location.block, buf);
    ip = (INODE *) buf + location.offset;
    mip->INODE = *ip;  // copy INODE to mp->INODE

    return mip;
}

int iput(MINODE *mip)
{
    char buf[BLKSIZE];
    INODE_LOCATION location;

    mip->refCount--;

    if (mip->refCount > 0) return 0;
    if (!mip->dirty)       return 0;

    location = mailman(mip->fs, mip->ino);

    get_block(mip->dev, location.block, buf);
    
    INODE *ip = (INODE*) buf + location.offset;
    memcpy(ip, &mip->INODE, sizeof(INODE));

    put_block(mip->dev, location.block, buf);

    return 0;
}

OFT *oget(MINODE *mip, int mode, int *fd)
{
    OFT *op;
    for (int i = 0; i < NOFT; i++)
    {
        if (oft[i].refCount == 0)
        {
            op = &oft[i];
            break;
        }
        
        //  Check whether the file is ALREADY opened with INCOMPATIBLE mode:
        //        If it's already opened for W, RW, APPEND : reject.
        //        (that is, only multiple R are OK)

        else if (oft[i].mptr == mip)
        {
            if (oft[i].mode != mode)
            {
                printf("File already opened in another mode\n");
                return NULL;
            }
            else
            {
                op = &oft[i];
                break;
            }
        }
    }

    for (int i = 0; i < NFD; i++)
    {
        if (running->fd[i] == NULL)
        {
            op->mptr = iget(mip->fs, mip->ino);
            op->mode = mode;
            op->refCount++;
            op->offset = 0;

            running->fd[i] = op;
            *fd = i;
            
            return op;
        }
    }

    switch (mode)
    {
        /// R and RW
        case 0: 
        case 2:
            op->offset = 0;
            break;
        /// W
        case 1: 
            truncate(mip);
            op->offset = 0;
            break;
        /// APPEND
        case 3:
            op->offset = mip->INODE.i_size;
            break;
        default: 
            printf("Invalid mode\n");
            return NULL;
    }

    return NULL;
}

int oput(OFT *op)
{
    op->refCount--;

    if (op->refCount == 0)
    { 
        iput(op->mptr);
        op->offset = 0;
        op->mptr = NULL;
        op->mode = -1;
    }
    return 0;
}

int search(MINODE *mip, char *name)
{
    // Returns ino of name if it exists in ip
    char buf[BLKSIZE];
    char dirname[EXT2_NAME_LEN];

    char* cp;
    DIR * dp;

    for (int i = 0; i < 12; i++)
    {
        if (!mip->INODE.i_block[i])
        {
            // printf("No more blocks! %s not found!\n", name);
            break;
        }

        get_block(mip->dev, mip->INODE.i_block[i], buf);
        dp = (DIR *) buf;
        cp = buf;

        while (cp < buf + BLKSIZE)
        {
            strncpy(dirname, dp->name, dp->name_len);
            dirname[dp->name_len] = '\0';

            if (!strcmp(dirname, name))
            {
                return dp->inode;
            }

            cp += dp->rec_len;
            dp = (DIR*) cp;
        }
    }

    // Couldn't find ino
    return -1;
}

int getino(MINODE *mip, char *pathname)
{
    // Return ino of pathname
    int ino;
    int n = tokenize(pathname, "/", tokens);

    for (int i = 0; i < n; i++)
    {
        ino = search(mip, tokens[i]);
        if (!ino)
        {
            // printf("can't find %s\n", tokens[i]);
            ino = -1;
            break;
        }
        mip = iget(mip->fs, ino);
    }
    return ino;
};

INODE_LOCATION mailman(FS *fs, int ino)
{
    INODE_LOCATION location;
    location.block  = (ino - 1) / 8 + fs->inode_start;
    location.offset = (ino - 1) % 8;
    return location;
}

int getdir(MINODE *mip, char *pathname)
{
    // Tries to get a valid directory from pathname
    char parent_path[256];
    int dest_ino;

    strcpy(parent_path, pathname);

    dest_ino = search(mip, pathname);

    if (dest_ino < 0)
    {
        // Try the parent, maybe the file doesn't exist yet
        strcpy(parent_path, dirname(parent_path));
        dest_ino = search(mip, parent_path);
    }

    if (dest_ino < 0)
    {
        printf("%s does not exist\n", parent_path);
        return -1;
    }
    else
    {
        // File exists: Check if it's a file or a dir
        mip = iget(mip->fs, dest_ino);
        if (!S_ISDIR(mip->INODE.i_mode))
        {
            printf("%s already exists\n", parent_path);
            return -1;
        }
        else
        {
            return dest_ino;
        }
    }
}

int insert_entry(MINODE *dir, DIR *file)
{
    // Insert dirent for file into dir's datablocks

    int blk, required, remain;
    char buf[BLKSIZE], *cp;

    DIR *dp, *last_rec, *new_rec;

    required = ideal_len(file);

    for (int i = 0; i < 12; i++)
    {
        blk = dir->INODE.i_block[i];

        if (!dir->INODE.i_block[i])
            break;

        get_block(dir->dev, blk, buf);
  
        dp = (DIR *) buf;  // Begin traversing data blocks
        cp = buf;
        
        // Find last entry in dir
        while (cp + dp->rec_len < buf + BLKSIZE)
        {
            cp += dp->rec_len;
            dp = (DIR *) cp;
        }
        last_rec = dp;

        // How many bytes remain in current block
        remain = last_rec->rec_len;

        if (remain >= required)
        {
            last_rec->rec_len = ideal_len(last_rec);
            remain -= last_rec->rec_len;
            
            cp += last_rec->rec_len;
            new_rec = (DIR *) cp;
            
            new_rec->inode = file->inode;
            new_rec->name_len = file->name_len;
            new_rec->rec_len = remain;
            strncpy(new_rec->name, file->name, file->name_len);

            put_block(dir->dev, blk, buf);
        }
        else
        {
            printf("Raise!!! we need to allocate another block");
            return 1;
        }
        // else
        // {
        //     int bno = balloc(dev);
        //     dir->INODE.i_size += BLKSIZE;
        //     get_block(dev, bno, buf);
        //     dp = (DIR*) dp;
        //     cp= buf;
        //     dp->rec_len = need_length;
        //     dp->inode = file->inode;
        //     dp->name_len = file->name_len;
        //     strcpy(dp->name, file->name);
        //     put_block(fd, ip->i_block[i + 1], buf);
        // }
    }

    return 0;
}

int delete_entry(MINODE* dir, char* name)
{
    char buf[BLKSIZE];

    DIR *dp, *prev = NULL;
    char *cp;

    DIR *delete = NULL, *before_delete = NULL, *last = NULL;

    int affected_block = -1;
    
    for (int i = 0; i < 12; i++)
    {
        if (!dir->INODE.i_block[i])
        {
            printf("No more blocks! %s not found!\n", name);
            return 1;
        }

        get_block(dir->dev, dir->INODE.i_block[i], buf);

        cp = buf;
        dp = (DIR *) buf;

        while (cp < buf + BLKSIZE)
        {
            if (!strncmp(dp->name, name, dp->name_len))
            {
                // We found the dir we wanted
                before_delete = prev;
                delete = dp;
                affected_block = i;  // This is the block that will be changed
            }

            prev = dp;
            cp += dp->rec_len;       // Move to next block
            dp = (DIR *) cp;
        }
        if (affected_block != -1)
        {
            last = prev;
            break;
        }
    }

    if (delete->rec_len == BLKSIZE)  // Only entry
    {
        bdalloc(dir->fs, dir->INODE.i_block[affected_block]);  // Boof the entire block
        
        dir->INODE.i_size -= BLKSIZE; // Decrement the block by the size of an entire block

        for (int j = affected_block; j < 11; j++)  // Scoot the next blocks over to the left by one
        {
            dir->INODE.i_block[j] =  dir->INODE.i_block[j + 1];
        }
        dir->INODE.i_block[11] = 0;
    }
    else
    {
        if (delete == last)  // Last entry in the block
        {
            // Increase size of previous entry to overwrite current dirent
            before_delete->rec_len += delete->rec_len;
        }
        else // This wasn't the last entry in the block
        {
            // Increase length of last entry by amount deleted
            last->rec_len += delete->rec_len;

            // Scoot the entire memoryspace over to squash the deleted entry
            memcpy((char *) delete, (char *) delete + delete->rec_len, (int) (buf + BLKSIZE - (char *) delete));
        }
    }
    
    put_block(dir->dev, dir->INODE.i_block[affected_block], buf);
    dir->dirty = 1;
    
    return 0;
}

int ideal_len(DIR* dirent)
{
    return 4 * ((8 + dirent->name_len + 3) / 4);
}

int truncate(MINODE *mip)
{
    // Deallocates all of the blocks used by inode
    int block, i = 0;;

    // While there are still blocks
    while ((block = get_ith_block(mip, i) != 0))
    {
        bdalloc(mip->fs, block);
        i++;
    }

    return i;  // Return number of blocks deallocated
}

char print_mode(u16 mode)
{
    char *mask  = "rwxrwxrwx";
    char *bmask = "---------";
    int index = 0;

    char filetype = '\0';

    if (S_ISDIR(mode))
        filetype = 'd';  // DIR
    else if (S_ISLNK(mode))
        filetype = 'l';  // LINK
    else
        filetype = ' ';  // REG

    printf("%c", filetype);

    for (int shift = 8; shift >= 0; shift--)
    {
        if ((mode >> shift) & 1)
        {
            printf("%c", mask[index]);
        }
        else
        {
            printf("%c", bmask[index]);
        }
        index++;
    }

    return filetype;
}

int get_ith_block(MINODE *mip, int i)
{
    char buf[BLKSIZE];
    // Get corresponding block # for index i in order
    INODE *ip = &mip->INODE;

    int n = BLKSIZE / sizeof(int);  // Number of bnos stored in each block
    
    int num_blocks = 12;
    int num_iblocks = n;
    int num_diblocks = n * n;

    if (i < 0)
    {
        puts("Invalid block number!");
        return -1;
    }
    // DIRECT BLOCKS: 0 <= i < 11
    else if (i < num_blocks)
    {
        return ip->i_block[i];
    }
    // INDIRECT BLOCK: 12
    else if (i < num_blocks + num_iblocks)
    {
        if (ip->i_block[12] != 0)
        {
            get_block(mip->dev, ip->i_block[12], buf);
            
            return ((int *) buf)[i - num_blocks];
        }
    }
    // DOUBLE INDIRECT BLOCK: 13
    else if (i < num_blocks + num_iblocks + num_diblocks)
    {
        if (ip->i_block[13] != 0)
        {
            // Get double indirect block contents
            get_block(mip->dev, ip->i_block[13], buf);

            int block  = ((i - (num_blocks + num_iblocks)) / n);
            int offset = ((i - (num_blocks + num_iblocks)) % n);
            
            // Get the corresponding 
            if (((int *) buf)[block] != 0)
            {
                get_block(mip->dev, ((int *) buf)[block], buf);

                return ((int *) buf)[offset];
            }
        }
    }
    return 0;
}
****************************************************
****************open_close.c **************************
****************************************************
#include "type.h"
OFT oft[NOFT];
FS     filesystems[NMOUNT], *root_fs, *cur_fs;

#define READ 0
#define WRITE 1
#define READWRITE 2
#define APPEND 3

int my_open(char* path, char* modeStr)
{
    int fd, ino;
    MINODE* wd, *mip;
    
    if (path[0] == '/')
    {
        // absolute path
        wd = root_fs->root;
        path++;
    }
    else
    {
        ///relative path
        wd =running->cwd;
    }

    ///DETERMINE MODE WE ARE OPENING IN
    int mode = 0;
    if(strcmp(modeStr, "R") == 0 || strcmp(modeStr, "0") == 0)
    {
        mode = READ;
    }
    else if(strcmp(modeStr, "W") == 0 || strcmp(modeStr, "1") == 0)
    {
        mode = WRITE;
    }
    else if(strcmp(modeStr, "RW") == 0 || strcmp(modeStr, "2") == 0)
    {
        mode = READWRITE;
    }
    else if(strcmp(modeStr, "APPEND") == 0 || strcmp(modeStr, "3") == 0)
    {
        mode = APPEND;
    }
    else
    {
        printf("%s is an invalid mode\n", modeStr);
        return -1;
    }

    char path_cpy[256];
    strcpy(path_cpy, path);
    ino = getino(wd, path_cpy);

    if (ino < 0)
    {
        if (mode != READ)
        {
            // Create file
            my_creat(1, &path);
            ino = getino(wd, path);
        }
        else
        {
            printf("%s doesn't exist\n", path);
            return -1;
        }
    }

    mip = iget(wd->fs, ino);

    if (S_ISDIR(mip->INODE.i_mode))
    {
        printf("%s is a dir, cannot be opened\n", path);
        return -2;  // Special DIR return value
    }
    else if (!S_ISREG(mip->INODE.i_mode))
    {
        printf("%s is not a file, cannot be opened\n", path);
        return -1;
    }
    
    oget(mip, mode, &fd);

    time_t now = time(0L);
    mip->INODE.i_atime = now;
    if (mode != READ)
    {
        mip->INODE.i_mtime = now;
    }
    mip->dirty = 1;

    return fd;
}

int my_close(int fd)
{
    if (running->fd[fd] == NULL || fd < 0 || fd >= NFD)
    {
        printf("Invalid fd!\n");
    }

    OFT* op = running->fd[fd];

    if (running->fd[fd] != NULL)
    {
        oput(op);
        running->fd[fd] = NULL;
    }
    else
    {
        printf("fd %d already closed\n", fd);
    }

    return 0;
}

int my_lseek(int fd, int position)
{
    OFT* oftp = running->fd[fd];
    int original = oftp->offset;
    if(position > oftp->mptr->INODE.i_size)
    {
        oftp->offset = position;
    }
    return original;
}

int pfd()
{
    printf(" fd    mode    offset    INODE\n");
    printf("----   ----     ----     ------\n");
    for(int i = 0; i < 10; i++)
    {
        printf("%d    %s    %d    [%d, %d]\n", i, running->fd[i]->mode == 0? "READ" : running->fd[i]->mode == 1? "WRITE" : running->fd[i]->mode == 2? "READWRITE" : running->fd[i]->mode == 3? "APPEND": " ", running->fd[i]->offset, running->fd[i]->mptr->dev,running->fd[i]->mptr->ino);
    }

    return 0;
}
****************************************************
****************main.c **************************
****************************************************
#include "type.h"

char *cmd_args[64];  // Used by interpreter
char line[256], command[128], cmd_arg_str[128];

PROC   proc[NPROC], *running;
FS     filesystems[NMOUNT], *root_fs, *cur_fs;

// FUNCTION POINTER TABLE
char *cmd_strs[] = {
    "ls",
    "pwd",
    "cd",
    "mkdir",
    "rmdir",
    "creat",
    "link",
    "symlink",
    "readlink",
    "unlink",
    "chmod",
    "touch",
    "stat",
    "cat",
    "cp",
    "mv",
    // "mount",
    // "umount",
    "menu",
    "quit"
};

int (*cmds[])(int, char **) = {
    (int (*)()) 
    ls,
    pwd,
    cd,
    my_mkdir,
    my_rmdir,
    my_creat,
    my_link,
    my_symlink,
    my_readlink,
    my_unlink,
    my_chmod,
    my_touch,
    my_stat,
    my_cat,
    my_cp,
    my_mv,
    // mount,
    // umount,
    my_menu,
    quit
};

int run_command(char *cmd, char *args)
{
    int argc;
    int num_commands = sizeof(cmd_strs) / sizeof(char *);

    for (int i = 0; i < num_commands; i++)
    {
        if (!strcmp(cmd, cmd_strs[i]))
        {
            argc = tokenize(args, " ", cmd_args);
            return cmds[i](argc, cmd_args);
        }
    }
    puts("Invalid command!");
    return -1;
}

// FUNCTIONS
int init()
{
    int i;
    PROC *p;
    OFT  *o;

    printf("init()\n");

    for (i = 0; i < NPROC; i++)
    {
        p = &proc[i];
        // set pid = i; uid = i; cwd = 0;  TODO: Check if this is correct
        p->pid = i;
        p->uid = i;
        p->cwd = 0;
        p->next = 0;
        p->cwd = 0;
    }
    for (int i = 0; i < NOFT; i++)
    {
        o = &oft[i];
        o->mode = -1;
        o->mptr = NULL;
        o->offset = 0;
        o->refCount = 0;
    }

    return 0;
}

int mount_root(FS *fs, char *fs_name)
{
    MINODE *mip;

    printf("mount_root()\n");
    for (int i = 0; i < NMINODE; i++)
    {
        mip = &fs->minode[i];
        // set all entries to 0;
        mip->dev = 0;
        mip->ino = 0;
        mip->refCount = 0;
        mip->dirty = 0;
        mip->mounted = 0;
        mip->fs = NULL;
    }

    char buf[BLKSIZE];
    int dev;

    SUPER *sp;
    GD    *gp;
    
    // open device for RW (get a file descriptor as dev for the opened device)
    // TODO: Pass AS ARGUMENT
    dev = open(fs_name, O_RDWR);
    
    if (dev < 0)
    {
        printf("Cannot open %s!\n", fs_name);
        exit(0);
    }
    fs->dev = dev;

    // read SUPER block to verify it's an EXT2 FS
    get_block(fs->dev, 1, buf);  
    sp = (SUPER *) buf;

    // check for EXT2 magic number:
    if (sp->s_magic != 0xEF53)
    {
        printf("NOT an EXT2 FS\n");
        exit(1);
    }

    // record nblocks, ninodes as globals
    fs->nblocks = sp->s_blocks_count;
    fs->ninodes = sp->s_inodes_count;

    //read GD0; record bamp, imap, inodes_start as globals;

    get_block(dev, 2, buf);
    gp = (GD *) buf;

    fs->imap = gp->bg_inode_bitmap;
    fs->bmap = gp->bg_inode_bitmap;
    fs->inode_start = gp->bg_inode_table;
    
    fs->root = iget(fs, 2);    /* get root inode */

    // Let cwd of both P0 and P1 point at the root minode (refCount=3) ??? TODO
    proc[0].cwd = iget(fs, 2); 
    proc[1].cwd = iget(fs, 2);
    printf("root refCount = %d\n", fs->root->refCount);

    //Let running -> P0
    running = &proc[0];

    return 0;
}

int main(int argc, char *argv[])
{
    init();
    
    root_fs = &filesystems[0];
    if (argc < 2)
        mount_root(root_fs, "mydisk");
    else
        mount_root(root_fs, argv[1]);
    cur_fs = root_fs;

    char *temp;

    while (1)
    {
        printf("Enter a command:\n");  // TODO: Dynamically print valid commands
        fgets(line, 256, stdin);
        line[strlen(line) - 1] = '\0'; // kill \n at end of line
        
        strcpy(command, strtok(line, " "));
        temp = strtok(NULL, "\n");
        if (temp)
            strcpy(cmd_arg_str, temp);  // Cut of tail of command for args
        else
            strcpy(cmd_arg_str, "");

        run_command(command, cmd_arg_str);

        strcpy(line, "");  // Reset line for next part
    }

    return 1;  // Somehow got out of loop?
}
****************************************************
****************chmod.c **************************
****************************************************
#include "type.h"

FS     filesystems[NMOUNT], *root_fs, *cur_fs;

int my_chmod(int argc, char* args[])
{
    if (argc < 2)
    {
        puts("Usage: file mode");
        return 1;
    }

    char *pathname = args[0];
    char *mode_str = args[1];

    unsigned long mode;

    int ino;

    MINODE *wd, *mip;

    if (pathname[0] == '/')
    {
        wd = root_fs->root;
        pathname++;
    }
    else
    {
        wd = running->cwd;
    }

    ino = getino(wd, pathname);
    mip = iget(wd->fs, ino);

    if (strlen(mode_str) == 3)
    {
        mode = strtoul(mode_str, NULL, 8);
    }
    else
    {
        printf("%s invalid mode\n", mode_str);
        return 1;
    }

    mip->INODE.i_mode = ((mip->INODE.i_mode >> 9) << 9) | mode;

    mip->dirty = 1;
    iput(mip);

    return 0;
}
****************************************************
****************creat.c **************************
****************************************************
#include "type.h"

FS     filesystems[NMOUNT], *root_fs, *cur_fs;

int newfile(FS *fs)
{
    int ino = ialloc(fs);
    int bno = balloc(fs);

    // Allocate the new File
    MINODE* mip = iget(fs, ino);
    INODE * ip  = &mip->INODE;

    ip->i_mode = (0x81A4);      // File with 0??? permissions
    ip->i_uid  = running->uid;	// Owner uid 
    ip->i_gid  = running->gid;	// Group Id
    ip->i_size = 0;		// Size in bytes 
    ip->i_links_count = 1;
    
    ip->i_mtime = time(0L);     // Set all three timestamps to current time
    ip->i_ctime = ip->i_mtime;
    ip->i_atime = ip->i_ctime;
    
    ip->i_blocks = 2;           // LINUX: Blocks count in 512-byte chunks 
    ip->i_block[0] = bno;       // new DIR has one data block   

    for (int i = 1; i < 15; i++)
    {
        ip->i_block[i] = 0;     // Set all blocks to 0
    }
    mip->dirty = 1;             // Set dirty for writeback

    iput(mip);

    return ino;
}

int my_creat(int argc, char* args[])
{
    if (argc < 1)
    {
        printf("Usage: path\n");
    }

    char *path = args[0];
    char parent_path[128], filename[128];

    int ino, pino;
    MINODE *mip, *pip;
    
    // path is pathname we wanna create
    if (path[0] == '/')
    {
        // absolute path
        mip = root_fs->root;
    }
    else
    {
        ///relative path
        mip = running->cwd;
    }

    strcpy(parent_path, path);
    strcpy(filename, path);
    
    strcpy(parent_path, dirname(parent_path));  // Will be "." if inserting in cwd
    strcpy(filename, basename(filename));

    pino = getino(mip, parent_path);
    pip = iget(mip->fs, pino);

    // checking if parent INODE is a dir 
    if (S_ISDIR(pip->INODE.i_mode))
    {
        // check child does not exist in parent directory
        ino = search(pip, filename);

        if (ino > 0)
        {
            printf("Child %s already exists\n", filename);
            return 1;
        }
    }

    ino = newfile(pip->fs);
    
    DIR dirent;
    dirent.inode = ino;
    strncpy(dirent.name, filename, strlen(filename));
    dirent.name_len = strlen(filename);
    dirent.rec_len = ideal_len(&dirent);

    insert_entry(pip, &dirent);
    
    pip->INODE.i_atime = time(0L);
    pip->dirty = 1;
    
    iput(pip);
    return 0;
}
****************************************************
****************mkdir.c **************************
****************************************************
#include "type.h"

FS     filesystems[NMOUNT], *root_fs, *cur_fs;

int newdir(MINODE *pip)
{
    // Creates a new directory under pip and returns ino

    int ino = ialloc(pip->fs);
    int bno = balloc(pip->fs);
    char buf[BLKSIZE];

    // Allocate the new Directory
    MINODE* mip = iget(pip->fs, ino);
    INODE * ip  = &mip->INODE;

    DIR* dp;
    char *cp;

    ip->i_mode = (0x41ED);      // Directory with 0??? permissions
    ip->i_uid  = running->uid;	// Owner uid 
    ip->i_gid  = running->gid;	// Group Id
    ip->i_size = BLKSIZE;		// Size in bytes 
    ip->i_links_count = 2;	    // Links count=2 because of . and ..
    
    ip->i_mtime = time(0L);     // Set all three timestamps to current time
    ip->i_ctime = ip->i_mtime;
    ip->i_atime = ip->i_ctime;
    
    ip->i_blocks = 2;           // LINUX: Blocks count in 512-byte chunks 
    ip->i_block[0] = bno;       // new DIR has one data block   

    for (int i = 1; i < 15; i++)
    {
        ip->i_block[i] = 0;     // Set all blocks to 0
    }
    
    mip->dirty = 1;             // Set dirty for writeback

    // Initializing the newly allocated block
    get_block(mip->dev, ip->i_block[0], buf);

    dp = (DIR *) buf;
    cp = buf;

    // Create initial "." directory
    strcpy(dp->name, ".");
    dp->inode = ino;
    dp->name_len = 1;
    dp->rec_len = 12;
    
    cp += dp->rec_len;
    dp = (DIR*) cp;

    // Create initial ".." directory
    strcpy(dp->name, "..");
    dp->inode = pip->ino;
    dp->name_len = 2;
    dp->rec_len = 1012;  // Uses up the rest of the block

    // Write back initialized dir block
    put_block(mip->dev, ip->i_block[0], buf);
    
    iput(mip);
    iput(pip);

    return ino;
}


int my_mkdir(int argc, char* args[])
{
    if (argc < 1)
    {
        puts("Usage: dir");
        return 1;
    }

    char* path = args[0];
    char parent_path[128], filename[128];

    int ino, pino;
    MINODE *mip, *pip;

    // path is pathname we wanna create
    if (path[0] == '/')
    {
        // absolute path
        mip = root_fs->root;
    }
    else
    {
        // relative path
        mip = running->cwd;
    }
    
    strcpy(parent_path, path);
    strcpy(filename, path);
    
    strcpy(parent_path, dirname(parent_path));  // Will be "." if inserting in cwd
    strcpy(filename, basename(filename));

    pino = getino(mip, parent_path);
    pip = iget(mip->fs, pino);

    // checking if parent INODE is a dir 
    if (S_ISDIR(pip->INODE.i_mode))
    {
        // check child does not exist in parent directory
        ino = search(pip, filename);

        if (ino > 0)
        {
            printf("Child %s already exists\n", filename);
            return 1;
        }
    }
    else
    {
        printf("%s is not a dir\n", parent_path);
        return 1;
    }

    ino = newdir(pip);  // Allocates a new directory
    pip->INODE.i_links_count++;

    DIR dirent;

    dirent.inode = ino;
    strncpy(dirent.name, filename, strlen(filename));
    dirent.name_len = strlen(filename);
    dirent.rec_len = ideal_len(&dirent);

    insert_entry(pip, &dirent);
    
    pip->INODE.i_atime = time(0L);
    pip->dirty = 1;
    iput(pip);

    return 0;
}
****************************************************
****************read_write.c **************************
****************************************************
#include "type.h"

extern PROC   proc[NPROC], *running;


int my_read(int fd, char buf[], int nbytes)
{
    char readbuf[BLKSIZE], *cp;

    OFT    *file = running->fd[fd];
    MINODE *mip  = file->mptr;
    
    file->refCount++;

    int count        = 0;

    int size         = file->mptr->INODE.i_size;
    
    int start_block  = file->offset / BLKSIZE;
    int start_byte   = file->offset % BLKSIZE; 
    int remain_block = BLKSIZE - start_byte;    // Number of bytes left in block (even if they're bad)
    int remain_file  = size - file->offset;     // Number of bytes left in file

    int i_block      = start_block;             // Block index
    int cur_block    = 0;                       // Actual block #

    int min;

    while (nbytes && remain_file)
    {
        min = nbytes;                           // Number of bytes to read
        if (remain_file < min)
            min = remain_file;
        if (remain_block < min)
            min = remain_block;

        cur_block = get_ith_block(mip, i_block);

        get_block(mip->dev, cur_block, readbuf);
        cp = readbuf + start_byte;
        start_byte = 0;

        memcpy(buf, cp, min);

        buf += min;
        count += min;
        file->offset += min;

        nbytes -= min;
        remain_file -= min;
        remain_block -= min;

        if (remain_block == 0)
        {
            i_block++;                           // Move to next block
            remain_block = BLKSIZE;
        }
    }

    file->refCount--;

    return count;  // Return actual number of bytes read
}

int my_write(int fd, char buf[], int nbytes)
{
    char writebuf[BLKSIZE], *cp;

    OFT    *file = running->fd[fd];
    MINODE *mip  = file->mptr;
    
    file->refCount++;
    mip->INODE.i_size = file->offset;

    int count        = 0;

    int start_block  = file->offset / BLKSIZE;
    int start_byte   = file->offset % BLKSIZE;
    int remain_block = BLKSIZE - start_byte;    // Number of bytes free in this block

    int i_block      = start_block;             // Block index
    int cur_block    = 0;                       // Actual block #

    int min;

    while (nbytes)
    {
        min = nbytes;                           // Number of bytes to read
        if (remain_block < min)
            min = remain_block;

        cur_block = get_ith_block(mip, i_block);
        get_block(mip->dev, cur_block, writebuf);

        cp = writebuf + start_byte;
        start_byte = 0;

        memcpy(cp, buf, min);

        put_block(mip->dev, cur_block, writebuf);

        buf += min;
        count += min;
        file->offset += min;

        nbytes -= min;
        remain_block -= min;

        if (remain_block == 0)
        {
            i_block++;                           // Move to next block
            remain_block = BLKSIZE;
        }
    }

    file->refCount--;
    mip->INODE.i_size += count;
    mip->dirty = 1;                              // Mark mip dirty

    return count;
}
****************************************************
****************unlink.c **************************
****************************************************
#include "type.h"

FS     filesystems[NMOUNT], *root_fs, *cur_fs;

int my_unlink(int argc, char* args[])
{
    if (argc < 1)
    {
        puts("Usage: file");
        return 1;
    }

    int ino, pino;

    char *pathname = args[0];
    char filename[128], parent_path[128];

    MINODE *wd, *mip, *pip;

    if (pathname[0] == '/')
    {
        wd = root_fs->root;
        pathname++;
    }
    else
    {
        wd = running->cwd;
    }

    strcpy(parent_path, pathname);
    strcpy(parent_path, dirname(parent_path));

    strcpy(filename, pathname);
    strcpy(filename, basename(filename));

    ino = getino(wd, pathname);
    mip = iget(wd->fs, ino);

    pino = getino(wd, parent_path);
    pip = iget(wd->fs, pino);

    if (S_ISDIR(mip->INODE.i_mode))
    {
        printf("Can't unlink: %s is a dir\n", pathname);
        return 1;
    }
    else
    {
        mip->INODE.i_links_count--;
        if (mip->INODE.i_links_count == 0)
        {
            if (S_ISREG(mip->INODE.i_mode))
            {
                truncate(mip);
            }
            else if (S_ISLNK(mip->INODE.i_mode))
            {
                // I don't think we need to do anything
            }
            idalloc(mip->fs, mip->ino);
        }

        // Remove the dirent from the parent
        delete_entry(pip, filename);
    }
    
    iput(mip);
    iput(pip);

    return 0;
}
****************************************************
****************touch.c **************************
****************************************************
#include "type.h"

FS     filesystems[NMOUNT], *root_fs, *cur_fs;

int my_touch(int argc, char* args[])
{
    if (argc < 1)
    {
        puts("Usage: file");
        return 1;
    }

    char* path = args[0];

    MINODE * mip, *wd;

    // path is pathname we wanna create
    if (path[0] == '/')
    {
        // absolute path
        wd = root_fs->root;
        path++;
    }
    else
    {
        ///relative path
        wd =running->cwd;
    }

    int ino = getino(wd, path);

    if (ino < 0)
    {
        ///create file
        my_creat(argc, args);
    }
    else
    {
        mip = iget(wd->fs, ino);

        mip->INODE.i_mtime = time(0L);
        mip->INODE.i_atime = mip->INODE.i_mtime;
    }

    return 0;
}
****************************************************
****************cd.c **************************
****************************************************
#include "type.h"

FS     filesystems[NMOUNT], *root_fs, *cur_fs;

int cd(int argc, char* args[])
{
    char *dirname = args[0];

    MINODE* mip = running->cwd;
    int ino = 0;

    if (dirname && dirname[0])
    {
        ino = getino(mip, dirname);
        
        if (ino > 0)
        {
            mip = iget(mip->fs, ino);

            if(S_ISDIR(mip->INODE.i_mode))
            {
                iput(running->cwd);
                running->cwd = mip;
                return 0;
            }
            else
            {
                printf("%s is not a directory\n", dirname);
                return 2;
            }
        }
        else
        {
            printf("%s does not exist\n", dirname);
            return 1;
        }
    }
    else  // Just cd into root
    {
        iput(running->cwd);
        running->cwd = root_fs->root;
        return 0;
    }
}
****************************************************
****************cp_mv.c **************************
****************************************************
#include "type.h"

char *tokens[64];
FS     filesystems[NMOUNT], *root_fs, *cur_fs;

int my_cp(int argv,char* args[])
{
    char* src = args[0];
    char* dest = args[1];

    int fd = my_open(src, "R");
    int gd = my_open(dest, "RW");

    if (gd == -2)  // Directory, we need to append src filename to dest
    {
        char actual_dest[256];
        char filename[128];

        strcpy(actual_dest, dest);

        strcpy(filename, src);
        strcpy(filename, basename(filename));  // Gets filename

        strcat(actual_dest, "/");
        strcat(actual_dest, filename);

        gd = my_open(actual_dest, "RW");
    }

    if (fd > -1 && gd > -1)
    {
        int n = 0;
        char buf[BLKSIZE];

        while((n = my_read(fd, buf, BLKSIZE)))
        {
            my_write(gd, buf, n);
        }

        my_close(fd);
        my_close(gd);

        return 0;
    }
    return 1;
}

int my_mv(int argv, char* args[])
{
    char* src = args[0];
    // char* dest = args[1]; 

    MINODE *wd;
    if (src[0] == '/')
    {
        // absolute path
        wd = root_fs->root;
        src++;
    }
    else
    {
        ///relative path
        wd =running->cwd;
    }
    
    int ino = getino(wd, src);
    if(ino == -1)
    {
        printf("%s does not exist\n", src);
    }

    if (my_cp(2, args) == 0)  // my_cp succeeded
    {
        my_unlink(1, &src);
        return 0;
    }
    return 1;
}
****************************************************
****************link.c **************************
****************************************************
#include "type.h"

char buf[BLKSIZE];
FS     filesystems[NMOUNT], *root_fs, *cur_fs;

// FUNCTIONS
int my_link(int argc, char* args[])
{
    if (argc < 2)
    {
        puts("Usage: source link");
        return 1;
    }

    char filename[256];
    int src_ino, dest_ino;
    char *src = args[0];
    char *dest = args[1];

    MINODE *wd;

    if (dest[0] == '/')
    {
        wd = root_fs->root;
        dest++;
    }
    else
    {
        wd = running->cwd;
    }
    
    // Get INO of destination folder
    dest_ino = getdir(wd, dest);

    if (dest_ino < 0)
    {  // No valid destination directory
        return -1;
    }
    else
    {  // Get the filename for the destination directory
        if (dest_ino == search(wd, dest))
        {  // Dest is a dir, use the original filename
            strcpy(filename, src);
        }
        else
        {  // Dest is a file, use the new filename
            strcpy(filename, dest);
        }
        strcpy(filename, basename(filename));
    }

    if (dest[0] == '/')
    {
        wd = root_fs->root;
        dest++;
    }
    else
    {
        wd = running->cwd;
    }

    // Get INO of file to link
    src_ino = getino(wd, src);

    MINODE *to_link = iget(wd->fs, src_ino);
    MINODE *dir = iget(wd->fs, dest_ino);

    // Add the link to the directory
    if (!S_ISDIR(to_link->INODE.i_mode))
    {
        DIR entry;
        entry.inode = to_link->ino;
        entry.name_len = strlen(filename);
        strcpy(entry.name, filename);
        entry.rec_len = ideal_len(&entry);

        insert_entry(dir, &entry);

        iput(to_link);
        iput(dir);

        // Update the refCount in memory
        INODE_LOCATION location = mailman(to_link->fs, to_link->ino);

        get_block(wd->fs->dev, location.block, buf);
        INODE *link = (INODE *) buf + location.offset;
        link->i_links_count++;
        put_block(wd->fs->dev, location.block, buf);
        
        return 0;
    }
    else
    {
        printf("Can't create link to dir\n");
        return 1;
    }
}
****************************************************
****************menu.c **************************
****************************************************
#include "type.h"

int my_menu(int argc, char* args[])
{
    printf("\n*********** COMMANDS *****************\n");
    printf("*ls pwd cd mkdir rmdir creat link    *\n");
    printf("*link symlink unlink chmod touch stat*\n");
    printf("*cat cp mv mount unmount quit        *\n");
    printf("**************************************\n\n");
    return 0;
}
****************************************************
****************cat.c **************************
****************************************************
#include "type.h"

FS     filesystems[NMOUNT], *root_fs, *cur_fs;

int my_cat(int argc, char* args[])
{
    char *path = args[0];

    char buf[BLKSIZE];

    if (argc < 1)
    {
        puts("Usage: file");
        return 1;
    }

    int n = 0;
    int fd = my_open(path, "R");

    while ((n  = my_read(fd, buf, BLKSIZE)))
    {
        write(1, buf, n);
    }
    puts("");

    my_close(fd);

    return 0;
}
****************************************************
****************pwd.c **************************
****************************************************
#include "type.h"

FS     filesystems[NMOUNT], *root_fs, *cur_fs;

// FUNCTIONS
int rpwd(MINODE *wd)
{
    char buf[BLKSIZE], dirname[BLKSIZE];
    int my_ino, parent_ino;

    DIR* dp;
    char* cp;

    MINODE* pip;  // Parent MINODE

    if (wd == root_fs->root)
    {
        return 0;
    }

    // Get dir block of cwd
    get_block(wd->dev, wd->INODE.i_block[0], buf);
    dp = (DIR *) buf;
    cp = buf;

    // Searches through cwd for cwd and parent ino
    // TODO: Replace with search?
    while(cp < buf + BLKSIZE)
    {
        strcpy(dirname, dp->name);
        dirname[dp->name_len] = '\0';
        
        if(!strcmp(dirname, "."))
        {
            my_ino = dp->inode;
        }
        if(!strcmp(dirname, ".."))
        {
            parent_ino = dp->inode;
        }

        cp += dp->rec_len;
        dp = (DIR*) cp;
    }

    pip = iget(wd->fs, parent_ino);
    get_block(wd->dev, pip->INODE.i_block[0], buf);
    dp = (DIR *) buf;
    cp = buf;

    while(cp < buf + BLKSIZE)
    {
        strncpy(dirname, dp->name, dp->name_len);
        dirname[dp->name_len] = '\0';
        
        if(dp->inode == my_ino)
        {
            break;
        }

        cp += dp->rec_len;
        dp = (DIR*) cp;
    }

    rpwd(pip);
    iput(pip);

    // Prints this part of cwd
    printf("/%s", dirname);
    return 0;
}

int pwd(int argc, char* args[])
{
    MINODE *wd = running->cwd;

    if(wd == root_fs->root)
    {
        printf("/");
    }
    else
    {
        rpwd(wd);
    }
    printf("\n");

    return 0;
}
****************************************************
****************stat.c **************************
****************************************************
#include "type.h"

FS     filesystems[NMOUNT], *root_fs, *cur_fs;

int my_stat(int argc, char* args[])
{
    if (argc < 1)
    {
        puts("Usage: file");
        return 1;
    }

    struct stat myst;
    char* path = args[0];

    MINODE * mip, *wd;

    // path is pathname we wanna create
    if (path[0] == '/')
    {
        // absolute path
        wd = root_fs->root;
    }
    else
    {
        ///relative path
        wd =running->cwd;
    }

    int ino = getino(wd, path);
    mip = iget(wd->fs, ino);

    time_t a_time = (time_t )mip->INODE.i_atime;
    time_t c_time = (time_t )mip->INODE.i_ctime;
    time_t m_time = (time_t )mip->INODE.i_mtime;    

    printf("\nFile: '%s'\n", path);
    printf("Size: %d    Blocks: %d    %s\n", mip->INODE.i_size, mip->INODE.i_blocks, S_ISDIR(myst.st_mode)? "Dir file": S_ISLNK(mip->INODE.i_mode)? "LNK File": "Regular File");
    printf("Device: %d    Inode: %d    Links: %d\n", wd->dev, ino, mip->INODE.i_links_count);
    printf("Access: (");
    printf("0%d/", S_ISDIR(myst.st_mode)? 755: 644);
    print_mode(mip->INODE.i_mode);
    printf(")    Uid: %d    Gid: %d\n",  mip->INODE.i_uid, mip->INODE.i_gid);
    printf("Access: %s",ctime(&a_time));
    printf("Modify: %s",ctime(&m_time));
    printf("Change: %s\n",ctime(&c_time));
    iput(mip);

    return 0;
}

****************************************************
****************quit.c **************************
****************************************************
#include "type.h"

FS     filesystems[NMOUNT], *root_fs, *cur_fs;

int quit(int argc, char *args[])
{
    for (int n = 0; n < NMOUNT; n++)
    {
        FS *fs = &filesystems[n];
        for (int i = 0; i < NMINODE; i++)
        {
            if (fs->minode[i].refCount > 0 && fs->minode[i].dirty)
            {
                iput(&fs->minode[i]);
            }
        }
    }
    exit(0);
}
****************************************************
****************ls.c **************************
****************************************************
#include "type.h"

FS     filesystems[NMOUNT], *root_fs, *cur_fs;

// FUNCTIONS
int ls_file(MINODE *mip, char *filename)
{
    char entryname[512];
    char linkname[84];
    strcpy(entryname, filename);

    char filetype = print_mode(mip->INODE.i_mode);

    if (filetype == 'l')  // Links are printed with the arrow
    {
        strcat(entryname, " -> ");
        getlink(mip, linkname);
        strcat(entryname, linkname);
    }

    printf(" %8d %s\n", mip->INODE.i_size, entryname);
    iput(mip);

    return 0;
}

int ls(int argc, char* args[])
{
    char *dirname = args[0];

    int ino;
    MINODE *wd, *pip, *mip;
    DIR *dp;
    char *cp, temp[256], dbuf[BLKSIZE];

    if (!dirname || !dirname[0])
    {
        wd = running->cwd;
        ino = running->cwd->ino;
    }
    else
    {
        if (dirname[0] == '/')
        {
            wd = root_fs->root;
            dirname++;
        }
        else
        {
            wd = running->cwd;
        }
        ino = getino(wd, dirname);
    }

    pip = iget(wd->fs, ino);
    

    if (S_ISDIR(pip->INODE.i_mode))
    {
        // TODO: Search the indirect blocks too
        for (int i = 0; i < 12; i++)
        {
            if (pip->INODE.i_block[i] == 0)
                break;

            get_block(wd->dev, pip->INODE.i_block[i], dbuf);
            dp = (DIR *) dbuf;
            cp = (char *) dbuf;

            while (cp < dbuf + BLKSIZE)
            {
                strncpy(temp, dp->name, dp->name_len);
                temp[dp->name_len] = '\0';

                if (temp[0] != '.')  // Skip hidden files
                {
                    mip = iget(wd->fs, dp->inode);
                    ls_file(mip, temp);
                }

                cp += dp->rec_len;  // Move to next record
                dp = (DIR *)cp;
            }
        }
    }
    else
    {
        printf("%s is not a dir\n", dirname);
    }

    iput(pip);
    iput(mip);

    return 0;
}
****************************************************
****************ialloc_balloc.c **************************
****************************************************
#include "type.h"

/********** globals *************/
FS     filesystems[NMOUNT], *root_fs, *cur_fs;

int tst_bit(char *buf, int bit)
{
    int i, j;
    i = bit/8; j=bit%8;
    if (buf[i] & (1 << j))
        return 1;
    return 0;
}

int set_bit(char *buf, int bit)
{
    int i, j;
    i = bit/8; j=bit%8;
    buf[i] |= (1 << j);

    return 0;
}

int clr_bit(char *buf, int bit)
{
    int i, j;
    i = bit/8; j=bit%8;
    buf[i] &= ~(1 << j);

    return 0;
}


int decFreeInodes(int dev)
{
    char buf[BLKSIZE];

    SUPER *sp;
    GD    *gp;

    // dec free inodes count in SUPER and GD
    get_block(dev, 1, buf);
    sp = (SUPER *)buf;
    sp->s_free_inodes_count--;
    put_block(dev, 1, buf);

    get_block(dev, 2, buf);
    gp = (GD *)buf;
    gp->bg_free_inodes_count--;
    put_block(dev, 2, buf);

    return 0;
}

int incFreeInodes(int dev)
{
    char buf[BLKSIZE];

    SUPER *sp;
    GD    *gp;

    // inc free inodes count in SUPER and GD
    get_block(dev, 1, buf);
    sp = (SUPER *) buf;
    sp->s_free_inodes_count++;
    put_block(dev, 1, buf);

    get_block(dev, 2, buf);
    gp = (GD *) buf;
    gp->bg_free_inodes_count++;
    put_block(dev, 2, buf);

    return 0;
}

int ialloc(FS *fs)
{
    int  i;
    char buf[BLKSIZE];

    // read inode_bitmap block
    get_block(fs->dev, fs->imap, buf);

    for (i=0; i < fs->ninodes; i++)
    {
        if (!tst_bit(buf, i))  // Inode not already allocated
        {
            set_bit(buf,i);
            decFreeInodes(fs->dev);

            put_block(fs->dev, fs->imap, buf);

            return i+1;
        }
    }
    printf("ialloc(): no more free inodes\n");
    return 0;
}

int balloc(FS *fs)
{
    int  i;
    char buf[BLKSIZE];

    // read inode_bitmap block
    get_block(fs->dev, fs->bmap, buf);

    for (i=0; i < fs->nblocks; i++)
    {
        if (!tst_bit(buf, i))  // Block not already allocated
        {
            set_bit(buf,i);
            decFreeInodes(fs->dev);

            put_block(fs->dev,  fs->bmap, buf);

            return i+1;
        }
    }
    printf("balloc(): no more free blocks\n");
    return 0;
}

void idalloc(FS *fs, int ino)
{
    char buf[BLKSIZE];
    if (ino > fs->ninodes)
    {
        printf("Error: ino %d out of range\n", ino);
        return;
    }
    get_block(fs->dev, fs->imap, buf);
    clr_bit(buf, ino-1);
    put_block(fs->dev, fs->imap, buf);
    incFreeInodes(fs->dev);
}

void bdalloc(FS *fs, int bno)
{
    char buf[BLKSIZE];
    if(bno > fs->nblocks)
    {
        printf("Error: ino %d out of range\n", bno);
        return;
    }
    get_block(fs->dev, fs->bmap, buf);
    clr_bit(buf, bno-1);
    put_block(fs->dev, fs->bmap, buf);
    incFreeInodes(fs->dev);
}
****************************************************
****************rmdir.c **************************
****************************************************
#include "type.h"

FS     filesystems[NMOUNT], *root_fs, *cur_fs;

int my_rmdir(int argc, char* args[])
{
    if (argc < 1)
    {
        puts("Usage: dir");
        return 1;
    }

    char* path = args[0];
    char parent_path[128], filename[128];

    int ino, pino;
    MINODE * mip, *wd;

    if (path[0] == '/')
    {
        wd = root_fs->root;
        path++;
    }
    else
    {
        wd =running->cwd;
    }

    strcpy(parent_path, path);
    strcpy(filename, path);

    strcpy(parent_path, dirname(parent_path));
    strcpy(filename, basename(filename));
    
    ino = getino(wd, path);

    if (ino < 0)
    {
        printf("%s not found!\n", path);
        return 1;
    }

    mip = iget(wd->fs, ino);

    if (running->uid != mip->INODE.i_uid && running->uid != 0)
    {
        printf("Cannot rmdir: permission denied\n");
        return 0;
    }
    else if (!S_ISDIR(mip->INODE.i_mode))
    {
        printf("Cannot rmdir: %s is not a dir\n", path);
        iput(mip);
        return -1;
    }
    else if (mip->INODE.i_links_count > 2)
    {
        printf("Cannot rmdir: %s is not empty\n", path);
        iput(mip);
        return -1;
    }
    else if (mip->INODE.i_links_count == 2)
    {
        char buf[BLKSIZE];
        DIR* dp;
        char* cp;

        get_block(wd->dev, mip->INODE.i_block[0], buf);
        
        cp = buf;
        dp = (DIR*) buf;

        cp += dp->rec_len;  // Get second entry in block
        dp = (DIR*) cp;

        // Second block of an empty disk will have rec_len of 1012
        if (dp->rec_len != 1012)
        {
            printf("Dir is not empty. Cannot be removed\n");
            iput(mip);
            return -1;
        }
    }

    truncate(mip);

    idalloc(mip->fs, mip->ino);
    iput(mip);

    // This will succeed because the getino for the child succeeded
    pino = getino(wd, parent_path);

    MINODE* pip = iget(wd->fs, pino);
    delete_entry(pip, filename);
    pip->INODE.i_links_count--;  // We just lost ".." from the deleted child
    pip->INODE.i_mtime = time(0L);
    pip->INODE.i_atime = pip->INODE.i_mtime;
    pip->dirty = 1;
    iput(pip);

    return 0;
}
****************************************************
****************symlink.c **************************
****************************************************
#include "type.h"

FS     filesystems[NMOUNT], *root_fs, *cur_fs;

// FUNCTIONS
int getlink(MINODE *mip, char buf[])
{
    // Copies link from mip->INODE.i_block[] to buf
    char *blocks = (char *) mip->INODE.i_block;
    memcpy(buf, blocks, 84);
    return 0;
}

int newsymlink(FS *fs, char *src)
{
    int ino = ialloc(fs);

    // Allocate the new File
    MINODE* mip = iget(fs, ino);
    INODE * ip  = &mip->INODE;

    ip->i_mode = (0xA1A4);      // File with 0??? permissions
    ip->i_uid  = running->uid;	// Owner uid 
    ip->i_gid  = running->gid;	// Group Id
    ip->i_size = strlen(src);   // Set size to length of name
    ip->i_links_count = 1;	    
    
    ip->i_mtime = time(0L);     // Set all three timestamps to current time
    ip->i_ctime = ip->i_mtime;
    ip->i_atime = ip->i_ctime;
    
    ip->i_blocks = 2;           // LINUX: Blocks count in 512-byte chunks 

    char *blocks = (char *) ip->i_block;

    memcpy(blocks, src, 84);

    mip->dirty = 1;             // Set dirty for writeback

    iput(mip);

    return ino;
}

int my_symlink(int argc, char* args[])
{
    if (argc < 2)
    {
        puts("Usage: file symlink");
        return 1;
    }

    // Copies src pathname into the i_block of an INODE
    char *src = args[0];
    char *dest = args[1];

    char parent_path[128], filename[128];

    int ino, pino;
    MINODE *mip, *pip;

    if (dest[0] == '/')
    {
        // absolute path
        mip = root_fs->root;
    }
    else
    {
        ///relative path
        mip = running->cwd;
    }

    strcpy(parent_path, dest);
    strcpy(filename, dest);
    
    strcpy(parent_path, dirname(parent_path));  // Will be "." if inserting in cwd
    strcpy(filename, basename(filename));

    pino = getino(mip, parent_path);
    pip = iget(mip->fs, pino);

    // checking if parent INODE is a dir 
    if (S_ISDIR(pip->INODE.i_mode))
    {
        // check child does not exist in parent directory
        ino = search(pip, filename);

        if (ino > 0)
        {
            printf("Child %s already exists\n", filename);
            return 1;
        }
    }

    ino = newsymlink(pip->fs, src);
    
    DIR dirent;
    dirent.inode = ino;
    strncpy(dirent.name, filename, strlen(filename));
    dirent.name_len = strlen(filename);
    dirent.rec_len = ideal_len(&dirent);

    insert_entry(pip, &dirent);
    
    pip->INODE.i_atime = time(0L);
    pip->dirty = 1;
    
    iput(pip);
    return 0;
}

int my_readlink(int argc, char* args[])
{
    if (argc < 1)
    {
        puts("Usage: symlink");
        return 1;
    }

    // Reads symlink to print destination
    char *pathname = args[0];

    char link[84];

    char parent_path[128], filename[128];

    int ino, pino;
    MINODE *mip, *pip, *wd;

    if (pathname[0] == '/')
    {
        // absolute path
        wd = root_fs->root;
    }
    else
    {
        ///relative path
        wd = running->cwd;
    }

    strcpy(parent_path, pathname);
    strcpy(filename, pathname);
    
    strcpy(parent_path, dirname(parent_path));  // Will be "." if inserting in cwd
    strcpy(filename, basename(filename));

    pino = getino(wd, parent_path);
    pip = iget(wd->fs, pino);

    // checking if parent INODE is a dir 
    if (S_ISDIR(pip->INODE.i_mode))
    {
        // check child does not exist in parent directory
        ino = search(pip, filename);

        if (ino < 0)
        {
            printf("Child %s already exists\n", filename);
            return 1;
        }
    }

    mip = iget(wd->fs, ino);

    getlink(mip, link);

    puts(link);

    return 0;
}
